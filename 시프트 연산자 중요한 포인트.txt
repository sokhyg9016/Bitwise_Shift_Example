C11 표준에 따르면 시프트 연산자 <<, >>는

1.
우측 피연산자의 값이 음수이거나, 
좌측 피연산자의 범위보다 큰 경우의 행위는 정의되지 않는다.(undefined)
2.
E1 >> E2일때, E1이 음수인 경우, 결과는 구현에 따라 달라진다.(implementation-defined)

라고 적혀있다.

또한 E1 << E2일대 E1이 음수인 경우의 동작은 정의되지 않으며,
     E1 >> E2일때 E1이 음수인 경우, 결과는 구현에 따라 달라진다.


그러나, 시프트 연산자와 관련되어 표준에서 정의되지 않은
IntelCPU의 특징이 있다.

시프트 연산자의 오른쪽 피연산자는

short: 하위 4바이트(1111 ~ 0000)의 범위에 대해서만 유효
int:   하위 5바이트(11111 ~ 00000)의 범위에 대해서만 유효
long long: 하위 6바이트(111111 ~ 000000)의 범위에 대해서만 유효

위와 같은 동작으로 정의된다.

즉, 만약 'int n = 1, n =<< 32'라고 할때, 시프트 연산자의 피연산자인 
'32'는 2진수로 표현하면 '10 0000'이다. 그러나 'n'은 데이터 타입이 
int 형이므로, 만약 시프트 연산자 사용시에 intelCPU를 사용한다면,
하위 5바이트(31 ~ 0)까지의 범위에 대해서만 유효하므로, 만약
범위를 넘게 된다면, 그 넘는 범위에 해당하는 자릿수의 비트는 제외된다.
즉, '32'는 '10 0000'으로 6비트이므로, 마지막 비트인 '1'은 제외되며,
최종적으로 'n =<< 32(10 0000)'에서  'n=<< 0(0 0000)'으로 변환되어
계산된다. 따라서 값은 변함없이 '1'이 된다.

















